import * as joint from "@joint/core/dist/joint.js"
import graphData from './schema-compliant-cdd.json' assert {type: 'json'}
import {DecisionElementArea} from "./decisionElementArea.js"
import {SaveButton} from "./uiButtons.js"

// --- CONFIG ---

const paperWidth = 800;
const paperHeight = 800;
const defaultRectWidth = 100;
const defaultRectHeight = 40;

// --- MAIN GRAPH SETUP ---

var namespace = joint.shapes;

var graph = new joint.dia.Graph({}, { cellNamespace: namespace });

//Define canvas (paper)
var paper = new joint.dia.Paper({
    el: document.getElementById('myholder'), //div in static/index.html
    model: graph,
    width: paperWidth,
    height: paperHeight,
    gridSize: 10,
    cellViewNamespace: namespace,
    interactive: function(cellView) {
        //Disable interaction on elements we've labeled non-interactive
        if(cellView.model.get('nonInteractive'))
        {
            return false;
        }

        //Otherwise, return the default value
        return {labelMove: false};
    }
});

//Lay out background areas
const graphAreas = new Array(
    new DecisionElementArea(0, 0.25, 0, 0.75, "#d6ffe1", "Lever"),
    new DecisionElementArea(0, 1, 0.75, 1, "#ffffd6", "External"),
    new DecisionElementArea(0.25, 0.75, 0, 0.75, "#d3e8eb", "Intermediate"),
    new DecisionElementArea(0.75, 1, 0, 0.75, "#e3d5ed", "Outcome")
);

for (const area of graphAreas)
{
    area.addAreaToGraph(graph, paperWidth, paperHeight);
}

//Read graph rectangle data from JSON
const graphRectsJSON = graphData.elements;

//Dictionary for storing runtime Rectangle objects
//Key: Rectangle UUID from JSON (string)
//Value: Rectangle object generated by JointJS
const graphRects = {};

//Send each rect's JSON data to add-to-graph function. Store runtime rects in the dict
graphRectsJSON.forEach((rectData) => graphRects[rectData.uuid] = addRectToGraph(rectData, graph));


//Read graph link data from JSON
const graphLinksJSON = graphData.dependencies;

//Dictionary for storing runtime Link objects
//Key: Link UUID from JSON (string)
//Value: Link object generated by JointJS
const graphLinks = {};

//Send each link to add-to-graph function
graphLinksJSON.forEach((linkData) => graphLinks[linkData.uuid] = addLinkToGraph(linkData, graph, graphRects));

//Dictionary for storing runtime Function Button objects
//Key: Button UUID generated by uuidv4
//Value: Function Button with JointJS object etc.
const functionButtons = {};

//SAVE BUTTON
const saveButton = new SaveButton([graphData, graphRects, graphLinks]);
functionButtons[saveButton.uuid] = saveButton;
saveButton.JointRect.addTo(graph);



// --- EVENTS ---

/**
 * Click event (elements)
 */
paper.on('element:pointerclick', function (cell) {
    //Handles all function buttons
    if(cell.model.get('isFunctionButton'))
    {
        //Get the button by id, call its callback function with the supplied args array
        const buttonId = cell.model.get('uuid');
        const button = functionButtons[buttonId];
        button.callback(...button.args);    //Spread args to convert array to arguments
    }
});

/**
 * Rectanlge - Position change (drag node):
 * Check area, update label (see onRectDrag)
 * 
 * This must be assigned to all nodes in the graph individually.
 */
for (const rect of Object.values(graphRects))
{
    rect.on("change:position", function(rectCell) {
        onRectDrag(rectCell);
    });
}

/**
 * Event function for when a rectangle element is being dragged.
 * Checks which graph area the rectangle is in, using DecisionElementArea.categorizeRect.
 * Based on area, updates element type field in model and in the element's label text.
 * @param {joint.dia.Element} cell The rectangle element being dragged. Should be in the graphRects dict.
 */
function onRectDrag(cell) {
    if(cell.isElement())
    {
        //Use the cell's model field for 'uuid' to find it in our runtime dict
        const rect = graphRects[cell.get('uuid')];
        if(rect !== null)
        {
            //Find what rect's Decision Element type should be based on what area it is in
            const newDecisionElementType = DecisionElementArea.categorizeRect(rect, graph);
            //Update label and the model field for 'elementType'
            cell.attr('label/text', newDecisionElementType);
            cell.set('elementType', newDecisionElementType);
        }
    }
}

// --- (OTHER) FUNCTIONS --

/**
 * Add a rectangle with the given JSON values to the given graph.
 * Rectangle JSON must be OpenDI-compliant.
 * 
 * @param {JSON} rectJSON Original raw JSON data for this rectangle
 * @param {joint.dia.Graph} graph Graph object to add this rectangle to
 * @param {Number} rectWidth (Optional) Width of this rectangle
 * @param {Number} rectHeight (Optional) Height of this rectangle
 * @returns {joint.shapes.standard.Rectangle} Runtime representation of the rectangle that was added
 */
function addRectToGraph(rectJSON, graph, rectWidth = defaultRectWidth, rectHeight = defaultRectHeight)
{
    var rectToAdd = new joint.shapes.standard.Rectangle();

    const rectDiagram = rectJSON.diagram;
    const rectType = rectJSON.type;

    //Basic attributes
    rectToAdd.position(rectDiagram.position.x, rectDiagram.position.y);
    rectToAdd.resize(rectDiagram.boundingBoxSize.width, rectDiagram.boundingBoxSize.height);

    //Hard-code some other attributes for now
    rectToAdd.attr({
        body: {
            fill: 'blue'
        },
        label: {
            text: rectType,
            fill: 'white'
        }
    });

    /*
     * -- SET MODEL FIELDS--
     * 
     * See JointJS docs: https://resources.jointjs.com/docs/jointjs/v4.0/joint.html#mvc.Model.prototype.set
     * 
     * Element rectangle models will have the following fields:
     * uuid (string) - This element's UID. Used for storage/lookup in runtime rect dict
     * elementType (string) - Used to store the type of Decision Element contained in this area
     */
    rectToAdd.set('uuid', rectJSON.uuid);
    rectToAdd.set('elementType', rectType)

    rectToAdd.addTo(graph);
    return rectToAdd; //For storing the runtime rect object
}

/**
 * Add a link with the given JSON values to the given graph.
 * Link JSON must be OpenDI-compliant.
 * 
 * @param {JSON} linkJSON Original raw JSON data for this link
 * @param {joint.dia.Graph} graph Graph object to add this link to
 * @param {Array<joint.shapes.standard.Rectangle>} rectsInGraph Array of all rects in the graph
 * @returns {joint.shapes.standard.Link} Runtime representation of the link that was added
 */
function addLinkToGraph(linkJSON, graph, rectsInGraph)
{
    var linkToAdd = new joint.shapes.standard.Link();

    //Find source by the uuid given in JSON data
    linkToAdd.source(rectsInGraph["" + linkJSON.source]);
    //Find target by the uuid given in JSON data
    linkToAdd.target(rectsInGraph["" + linkJSON.target]);

    linkToAdd.addTo(graph);
    return linkToAdd; //For storing the runtime link object
}