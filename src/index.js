import * as joint from "@joint/core/dist/joint.js"
import graphData from './schema_compliant_cdd.json' assert {type: 'json'}
import {SaveButton, FunctionButton} from "./uiButtons.js"
import {DecisionElement} from "./graphComponents/decisionElement.js"
import {CausalDependency} from "./graphComponents/causalDependency.js"
import { SelectionBuffer } from "./selectionBuffer/selectionBuffer.js"
import {Config} from "./config.js"
import { v4 as uuidv4 } from 'uuid';

// --- MAIN GRAPH SETUP ---
var namespace = {
    shapes: joint.shapes,
    DecisionElement
}

var graph = new joint.dia.Graph({}, { cellNamespace: namespace });

//Define canvas (paper)
var paper = new joint.dia.Paper({
    el: document.getElementById('myholder'), //div in static/index.html
    model: graph,
    width: Config.paperWidth,
    height: Config.paperHeight,
    background: {
        color: "#999999"
    },
    gridSize: 10,
    cellViewNamespace: namespace,
    interactive: function(cellView) {
        //Disable interaction on elements we've labeled non-interactive
        if(cellView.model.get('nonInteractive'))
        {
            return false;
        }

        //Otherwise, return the default value
        return {labelMove: false};
    }
});

//Read graph rectangle data from JSON
const graphElementsJSON = graphData.diagrams[0].elements;

//Dictionary for storing runtime Rectangle objects
//Key: Rectangle UUID from JSON (string)
//Value: Rectangle object generated by JointJS
const graphElements = {};

//Defined in selectionBuffer/selectionBuffer.js
//Keeps track of selected elements
const selectionBuffer = new SelectionBuffer();

//Send each rect's JSON data to add-to-graph function. Store runtime rects in the dict
graphElementsJSON.forEach((rectData) => {
        graphElements[rectData.meta.uuid] = DecisionElement.addElementToGraph(rectData, graph, paper);
    }
);

//Read graph link data from JSON
const graphDependenciesJSON = graphData.diagrams[0].dependencies;

//Dictionary for storing runtime Link objects
//Key: Link UUID from JSON (string)
//Value: Link object generated by JointJS
const graphLinks = {};

//Send each link to add-to-graph function
graphDependenciesJSON.forEach((depData) => {
    graphLinks[depData.meta.uuid] = CausalDependency.addLinkToGraph(depData, graph, graphElements);
});

//Dictionary for storing runtime Function Button objects
//Key: Button UUID generated by uuidv4
//Value: Function Button with JointJS object etc.
const functionButtons = {};

//SAVE BUTTON
const saveButton = new SaveButton([graphData, graphElements, graphLinks]);
functionButtons[saveButton.uuid] = saveButton;
saveButton.JointRect.addTo(graph);

const newElementButton = new FunctionButton(0, 25, 80, 20, "New Elem", addNewElement, [graphElements, graph, paper]);
functionButtons[newElementButton.uuid] = newElementButton;
newElementButton.JointRect.addTo(graph);

const deleteElementButton = new FunctionButton(0, 50, 80, 20, "Del Elem", deleteElements, [selectionBuffer, graphElements, graphLinks]);
functionButtons[deleteElementButton.uuid] = deleteElementButton;
deleteElementButton.JointRect.addTo(graph);

const toggleDependencyButton = new FunctionButton(0, 75, 80, 20, "Toggle Dep", toggleDependency, [selectionBuffer, graphElements, graphLinks, graph]);
functionButtons[toggleDependencyButton.uuid] = toggleDependencyButton;
toggleDependencyButton.JointRect.addTo(graph);

//TEST ADD NEW ELEMENT
function addNewElement(graphElementsMap, graph, paper)
{
    const newElementUUID = uuidv4();
    const addElementJSON = {
        "meta": {
            "uuid": newElementUUID,
            "name": "TEST ADD"
        },
        "causalType": "Lever",
        "diaType": "box",
        "content": {
            "position": {
                "x": 100,
                "y": 100
            },
            "boundingBoxSize": {
                "width": 400,
                "height": 500
            }
        }
    };

    graphElementsMap[newElementUUID] = DecisionElement.addElementToGraph(addElementJSON, graph, paper);
    //Don't add to elements OG JSON map
}

function deleteDependency(depUUID, graphLinksMap)
{
    //Deregister this dependency from the "associated dependencies" list in its source and target DecisionElement objects
    const deregisterSelf = (depUUID) => {
        const dep = graphLinksMap[depUUID];
        const idxAtSource = dep.runtimeSource.associatedDependencies.indexOf(depUUID);
        const idxAtTarget = dep.runtimeTarget.associatedDependencies.indexOf(depUUID);
        dep.runtimeSource.associatedDependencies.splice(idxAtSource, 1);
        dep.runtimeTarget.associatedDependencies.splice(idxAtTarget, 1);
    }

    deregisterSelf(depUUID);            //Helper defined above
    graphLinksMap[depUUID].remove();    //JointJS: remove from actual graph
    delete graphLinksMap[depUUID];      //Remove from master dict of links
}

//TEST DELETE ELEMENT
function deleteElements(selectionBuffer, graphElementsMap, graphLinksMap)
{
    //Filter an array to unique values only
    //Thanks: https://stackoverflow.com/a/14438954
    const uniqueFilter = (value, index, array) => {
        return array.indexOf(value) === index;
    }

    //Get arrays of elements and dependencies to delete. Use counts for confirmation dialogue.
    const elemsToDelete = selectionBuffer.buffer.filter(uniqueFilter);
    const numElemsToDelete = elemsToDelete.length;

    let depsToDelete = [];
    elemsToDelete.forEach((elem) => {
        depsToDelete.push(...elem.associatedDependencies);
    });
    depsToDelete = depsToDelete.filter(uniqueFilter);
    const numDepsToDelete = depsToDelete.length;

    if(confirm("Deleting  " + numElemsToDelete + " element/s and " + numDepsToDelete + " associated dependency/ies. Are you sure?"))
    {
        //Delete all dependencies
        depsToDelete.forEach((depUUID) => {
            deleteDependency(depUUID, graphLinksMap);
        });

        //Delete all elements
        elemsToDelete.forEach((elem) => {
            elem.remove();                                          //JointJS: remove from actual graph
            delete graphElementsMap[elem.originalJSON.meta.uuid];   //Remove from master dict of elements
        });
    }
}

/**
 * Creates a fresh dependency with the given source and target elements, and adds it to the given graph.
 * 
 * @param {DecisionElement} sourceElem Source element for the dependency
 * @param {DecisionElement} targetElem Target element for the dependency
 * @param {Map<string,CausalDependency>} graphLinksMap Map of dependency UUIDs to runtime representations of dependencies
 * @param {Map<string,DecisionElement>} graphElementsMap Map of element UUIDs to runtime representations of elements
 * @param {joint.dia.graph} graph Graph to add dependency to
 */
function addNewDependency(sourceElem, targetElem, graphLinksMap, graphElementsMap, graph)
{
    const newDepUUID = uuidv4();
    const newDepName = "" + sourceElem.originalJSON.meta.name + " --> " + targetElem.originalJSON.meta.name;
    const sourceUUID = sourceElem.originalJSON.meta.uuid;
    const targetUUID = targetElem.originalJSON.meta.uuid;
    const addDepJSON = {
        "meta": {
            "uuid": newDepUUID,
            "name": newDepName
        },
        "source": sourceUUID,
        "target": targetUUID
    };

    graphLinksMap[newDepUUID] = CausalDependency.addLinkToGraph(addDepJSON, graph, graphElementsMap);
}

//TEST TOGGLE DEPENDENCY
function toggleDependency(selectionBuffer, graphElementsMap, graphLinksMap, graph)
{
    /**
     * lil helper function
     * Checks to see if a dependency already exists between the given source element and target element.
     * If found, returns UUID for the dependency. Otherwise, returns null.
     * @param {DecisionElement} sourceElem Source element to check
     * @param {DecisionElement} targetElem Target element to check
     * @returns {string} UUID of found existing dependency. null if no dependency found.
     */
    const dependencyExists = (sourceElem, targetElem) => {
        const targetUUID = targetElem.originalJSON.meta.uuid;
        let result = null;
        //Check associated dependencies on the source.
        //See if associated target matches the target we're checking.
        sourceElem.associatedDependencies.forEach((depUUID) => {
            const associatedTargetUUID = graphLinksMap[depUUID].runtimeTarget.originalJSON.meta.uuid;
            if(associatedTargetUUID == targetUUID)
            {
                result = depUUID;
            }
        });

        return result;
    }

    
    //MAIN LOGIC STARTS HERE

    //Make sure we have enough selected to bother
    if(selectionBuffer.buffer.length >= 2)
    {
        /**
         * Run through the selection buffer, pairwise. Initially, assume that we will add
         * new deps wherever they are missing. However, if we get to the end of the buffer
         * and no deps were missing, remove all deps. To make this easier, keep a running
         * list of existing deps until the first "hole" is found. That way, if no holes
         * exist, we'll have our list of deletions ready.
         */
        let someDepsMissing = false;
        let existingDeps = [];
        for(let bufferIdx = 0; bufferIdx + 1 < selectionBuffer.buffer.length; bufferIdx++)
        {
            //Skip instances where consecutive selections are the same (double-selected one element)
            if(selectionBuffer.buffer[bufferIdx].originalJSON.meta.uuid !== selectionBuffer.buffer[bufferIdx + 1].originalJSON.meta.uuid)
            {
                const existingDepUUID = dependencyExists(selectionBuffer.buffer[bufferIdx], selectionBuffer.buffer[bufferIdx + 1]);
                if(existingDepUUID !== null)
                {
                    //If this flag is set, no need to occupy more memory. We won't use this array.
                    if(!someDepsMissing)
                    {
                        existingDeps.push(existingDepUUID);
                    }
                }
                else
                {
                    someDepsMissing = true;
                    addNewDependency(selectionBuffer.buffer[bufferIdx], selectionBuffer.buffer[bufferIdx + 1], graphLinksMap, graphElementsMap, graph);
                }
            }
        }

        //If we got through the whole buffer and added no new deps,
        //delete all existing deps.
        if(!someDepsMissing)
        {
            existingDeps.forEach((depUUID) => {
                deleteDependency(depUUID, graphLinksMap);
            });
        }
    }
}



// --- EVENTS ---

/**
 * Click event (elements)
 */
paper.on('element:pointerclick', function (cell) {
    const cellUUID = cell.model.get('uuid');

    //Handles all function buttons
    if(cell.model.get('isFunctionButton'))
    {
        //Get the button by id, call its callback function with the supplied args array
        const button = functionButtons[cellUUID];
        button.callback(...button.args);    //Spread args to convert array to arguments
    }
});

/**
 * Pointer up event (elements)
 */
paper.on('element:pointerup', function (cellView)
{
    const cellUUID = cellView.model.get('uuid');

    //See if it's a decision element
    const decisionElem = graphElements[cellUUID];
    if(decisionElem != null)
    {
        //Select the element
        selectionBuffer.bufferSize = SelectionBuffer.DefaultBufferSize;
        selectionBuffer.updateSelections(graphLinks, decisionElem);
    }
});

/**
 * Pointer up event (non-element, blank area of the paper)
 */
paper.on('blank:pointerup', function (evt, x, y) {
    //Deselect elements
    selectionBuffer.bufferSize = SelectionBuffer.DefaultBufferSize;
    selectionBuffer.updateSelections(graphLinks);
});

/**
 * Right-click event (elements)
 */
paper.on('element:contextmenu', function(cell) {
    const cellUUID = cell.model.get('uuid');

    //See if it's a decision element
    const decisionElem = graphElements[cellUUID];
    if(decisionElem != null)
    {
        //Multi-select elements
        selectionBuffer.bufferSize = SelectionBuffer.MaxBufferSize;
        selectionBuffer.updateSelections(graphLinks, decisionElem);
    }
})
