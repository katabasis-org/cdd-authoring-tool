import * as joint from "@joint/core/dist/joint.js"
import graphData from './schema_compliant_cdd.json' assert {type: 'json'}
import {SaveButton} from "./uiButtons.js"
import { HTMLNode, HTMLNodeView, HTMLNodeEditTool } from "./htmlNode.js"
import {Config} from "./config.js"

// --- MAIN GRAPH SETUP ---
var namespace = {
    shapes: joint.shapes,
    HTMLNode,
    HTMLNodeView
}

var graph = new joint.dia.Graph({}, { cellNamespace: namespace });

//Define canvas (paper)
var paper = new joint.dia.Paper({
    el: document.getElementById('myholder'), //div in static/index.html
    model: graph,
    width: Config.paperWidth,
    height: Config.paperHeight,
    background: {
        color: "#888888"
    },
    gridSize: 10,
    cellViewNamespace: namespace,
    interactive: function(cellView) {
        //Disable interaction on elements we've labeled non-interactive
        if(cellView.model.get('nonInteractive'))
        {
            return false;
        }

        //Otherwise, return the default value
        return {labelMove: false};
    }
});

//Read graph rectangle data from JSON
const graphElementsJSON = graphData.diagrams[0].elements;

//Dictionary for storing original JSON representation of each element
//Key: Element UUID from JSON
//Value: Original JSON object for this element
const elementsJSONMap = {};

//Dictionary for storing runtime Rectangle objects
//Key: Rectangle UUID from JSON (string)
//Value: Rectangle object generated by JointJS
const graphElements = {};

//Send each rect's JSON data to add-to-graph function. Store runtime rects in the dict
graphElementsJSON.forEach((rectData) => {
        graphElements[rectData.meta.uuid] = addElementToGraph(rectData, graph, paper);
        elementsJSONMap[rectData.meta.uuid] = rectData;
    }
);


//Read graph link data from JSON
const graphLinksJSON = graphData.diagrams[0].dependencies;

//Dictionary for storing runtime Link objects
//Key: Link UUID from JSON (string)
//Value: Link object generated by JointJS
const graphLinks = {};

//Send each link to add-to-graph function
graphLinksJSON.forEach((linkData) => graphLinks[linkData.uuid] = addLinkToGraph(linkData, graph, graphElements));

//Dictionary for storing runtime Function Button objects
//Key: Button UUID generated by uuidv4
//Value: Function Button with JointJS object etc.
const functionButtons = {};

//SAVE BUTTON
const saveButton = new SaveButton([graphData, graphElements, graphLinks, elementsJSONMap]);
functionButtons[saveButton.uuid] = saveButton;
saveButton.JointRect.addTo(graph);



// --- EVENTS ---

/**
 * Click event (elements)
 */
paper.on('element:pointerclick', function (cell) {
    //Handles all function buttons
    if(cell.model.get('isFunctionButton'))
    {
        //Get the button by id, call its callback function with the supplied args array
        const buttonId = cell.model.get('uuid');
        const button = functionButtons[buttonId];
        button.callback(...button.args);    //Spread args to convert array to arguments
    }
});

/**
 * Mouse hover events - mouse enter
 */
paper.on('element:mouseenter', function(view) {
    view.showTools(); //Show edit button
});

/**
 * Mouse hover events - mouse leave
 */
paper.on('element:mouseleave', function(view) {
    view.hideTools(); //Hide edit button
});

// --- (OTHER) FUNCTIONS --

/**
 * Add an element with the given JSON values to the given graph.
 * Element JSON must be OpenDI-compliant.
 * 
 * @param {JSON} elementJSON Original raw JSON data for this element
 * @param {joint.dia.Graph} graph Graph object to add this element to
 * @param {Number} elementMaxWidth (Optional) Maximum width of this element
 * @returns {HTMLNode} Runtime representation of the element that was added
 */
function addElementToGraph(elementJSON, graph, paper, elementMaxWidth = Config.maxElementWidth, charWidth = 7)
{
    const diagramJSON = elementJSON.content;
    const elementType = elementJSON.causalType;
    const elementTitle = elementJSON.meta.name;

    //Add a new element to the graph
    const elementToAdd = new HTMLNode();
    elementToAdd.addTo(graph);

    // -- TOOLS SETUP --
    
    const toolView = new joint.dia.ToolsView({
        tools: [new HTMLNodeEditTool()]
    });
    elementToAdd.findView(paper).addTools(toolView);
    elementToAdd.findView(paper).hideTools();

    // -- SET VISUAL ATTRIBUTES --

    //Position
    elementToAdd.position(diagramJSON.position.x, diagramJSON.position.y);

    //Title, type
    elementToAdd.attr({
        view_label_title: {
            text: HTMLNode.formatString(elementTitle, elementMaxWidth / charWidth)
        },
        view_label_type: {
            text: elementType
        }
    });

    //Size
    HTMLNode.resizeElementBasedOnText(elementToAdd, paper, "view_");

    //Type (Set dropdown <select> menu to pre-select the right type)
    const typeAttrString = 'select' + elementType + "/props/selected";
    elementToAdd.attr(typeAttrString, true);

    /*
     * -- SET MODEL FIELDS --
     * 
     * See JointJS docs: https://resources.jointjs.com/docs/jointjs/v4.0/joint.html#mvc.Model.prototype.set
     * 
     * Element rectangle models will have the following fields:
     * uuid (string) - This element's UID. Used for storage/lookup in runtime rect dict
     * name (string) - This element's human-readable name. Used for display on the diagram.
     * elementType (string) - Used to store the type of Decision Element contained in this area
     * viewMode (enum ["view", "edit"]) - Currently not used? (TODO: Investigate 2024-08-28)
     */
    elementToAdd.set('uuid', elementJSON.uuid);
    elementToAdd.set('elementType', elementType);
    elementToAdd.set('name', elementTitle);
    elementToAdd.set('viewMode', 'view');

    return elementToAdd; //For storing the runtime rect object
}

/**
 * Add a link with the given JSON values to the given graph.
 * Link JSON must be OpenDI-compliant.
 * 
 * @param {JSON} linkJSON Original raw JSON data for this link
 * @param {joint.dia.Graph} graph Graph object to add this link to
 * @param {Array<joint.shapes.standard.Rectangle>} rectsInGraph Array of all rects in the graph
 * @returns {joint.shapes.standard.Link} Runtime representation of the link that was added
 */
function addLinkToGraph(linkJSON, graph, rectsInGraph)
{
    var linkToAdd = new joint.shapes.standard.Link();

    //Find source by the uuid given in JSON data
    linkToAdd.source(rectsInGraph["" + linkJSON.source]);
    //Find target by the uuid given in JSON data
    linkToAdd.target(rectsInGraph["" + linkJSON.target]);

    linkToAdd.addTo(graph);
    return linkToAdd; //For storing the runtime link object
}