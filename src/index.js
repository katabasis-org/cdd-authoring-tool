import * as joint from "@joint/core/dist/joint.js"
import graphData from './schema_compliant_cdd.json' assert {type: 'json'}
import {SaveButton, FunctionButton} from "./uiButtons.js"
import {DecisionElement} from "./decisionElement/decisionElement.js"
import { SelectionBuffer } from "./selectionBuffer/selectionBuffer.js"
import {Config} from "./config.js"
import { v4 as uuidv4 } from 'uuid';

// --- MAIN GRAPH SETUP ---
var namespace = {
    shapes: joint.shapes,
    DecisionElement
}

var graph = new joint.dia.Graph({}, { cellNamespace: namespace });

//Define canvas (paper)
var paper = new joint.dia.Paper({
    el: document.getElementById('myholder'), //div in static/index.html
    model: graph,
    width: Config.paperWidth,
    height: Config.paperHeight,
    background: {
        color: "#888888"
    },
    gridSize: 10,
    cellViewNamespace: namespace,
    interactive: function(cellView) {
        //Disable interaction on elements we've labeled non-interactive
        if(cellView.model.get('nonInteractive'))
        {
            return false;
        }

        //Otherwise, return the default value
        return {labelMove: false};
    }
});

//Read graph rectangle data from JSON
const graphElementsJSON = graphData.diagrams[0].elements;

//Dictionary for storing original JSON representation of each element
//Key: Element UUID from JSON
//Value: Original JSON object for this element
const elementsJSONMap = {};

//Dictionary for storing runtime Rectangle objects
//Key: Rectangle UUID from JSON (string)
//Value: Rectangle object generated by JointJS
const graphElements = {};

//Defined in selectionBuffer/selectionBuffer.js
//Keeps track of selected elements
const selectionBuffer = new SelectionBuffer();

//Send each rect's JSON data to add-to-graph function. Store runtime rects in the dict
graphElementsJSON.forEach((rectData) => {
        graphElements[rectData.meta.uuid] = DecisionElement.addElementToGraph(rectData, graph, paper);
        elementsJSONMap[rectData.meta.uuid] = rectData;
    }
);

//Read graph link data from JSON
const graphDependenciesJSON = graphData.diagrams[0].dependencies;

//Dictionary for storing original JSON representation of each dependency
//Key: Dependency UUID from JSON
//Value: Original JSON object for this dependency
const dependenciesJSONMap = {};

//Dictionary for storing runtime Link objects
//Key: Link UUID from JSON (string)
//Value: Link object generated by JointJS
const graphLinks = {};

//Send each link to add-to-graph function
graphDependenciesJSON.forEach((depData) => {
    graphLinks[depData.meta.uuid] = addLinkToGraph(depData, graph, graphElements);
    dependenciesJSONMap[depData.meta.uuid] = depData;
});

//Dictionary for storing runtime Function Button objects
//Key: Button UUID generated by uuidv4
//Value: Function Button with JointJS object etc.
const functionButtons = {};

//SAVE BUTTON
const saveButton = new SaveButton([graphData, graphElements, graphLinks, elementsJSONMap, dependenciesJSONMap]);
functionButtons[saveButton.uuid] = saveButton;
saveButton.JointRect.addTo(graph);

const newElementButton = new FunctionButton(0, 25, 80, 20, "New Elem.", addNewElement, [graphElements, graph, paper]);
functionButtons[newElementButton.uuid] = newElementButton;
newElementButton.JointRect.addTo(graph);

//TEST ADD NEW ELEMENT
function addNewElement(graphElementsMap, graph, paper)
{
    const newElementUUID = uuidv4();
    const addElementJSON = {
        "meta": {
            "uuid": newElementUUID,
            "name": "TEST ADD"
        },
        "causalType": "Lever",
        "diaType": "box",
        "content": {
            "position": {
                "x": 100,
                "y": 100
            },
            "boundingBoxSize": {
                "width": 400,
                "height": 500
            }
        }
    };

    graphElementsMap[newElementUUID] = DecisionElement.addElementToGraph(addElementJSON, graph, paper);
    //Don't add to elements OG JSON map
}



// --- EVENTS ---

/**
 * Click event (elements)
 */
paper.on('element:pointerclick', function (cell) {
    const cellUUID = cell.model.get('uuid');

    //Handles all function buttons
    if(cell.model.get('isFunctionButton'))
    {
        //Get the button by id, call its callback function with the supplied args array
        const button = functionButtons[cellUUID];
        button.callback(...button.args);    //Spread args to convert array to arguments
    }
});

/**
 * Pointer up event (elements)
 */
paper.on('element:pointerup', function (cellView)
{
    const cellUUID = cellView.model.get('uuid');

    //See if it's a decision element
    const decisionElem = graphElements[cellUUID]
    if(decisionElem != null)
    {
        selectionBuffer.updateSelections(decisionElem);
    }
});

/**
 * Pointer up event (non-element, blank area of the paper)
 */
paper.on('blank:pointerup', function (evt, x, y) {
    selectionBuffer.updateSelections();
});


// --- (OTHER) FUNCTIONS --


/**
 * Add a link with the given JSON values to the given graph.
 * Link JSON must be OpenDI-compliant.
 * 
 * @param {JSON} linkJSON Original raw JSON data for this link
 * @param {joint.dia.Graph} graph Graph object to add this link to
 * @param {Array<joint.shapes.standard.Rectangle>} rectsInGraph Array of all rects in the graph
 * @returns {joint.shapes.standard.Link} Runtime representation of the link that was added
 */
function addLinkToGraph(linkJSON, graph, rectsInGraph)
{
    var linkToAdd = new joint.shapes.standard.Link();

    //Find source by the uuid given in JSON data
    linkToAdd.source(rectsInGraph["" + linkJSON.source]);
    //Find target by the uuid given in JSON data
    linkToAdd.target(rectsInGraph["" + linkJSON.target]);

    linkToAdd.set('uuid', linkJSON.meta.uuid);
    linkToAdd.set('name', linkJSON.meta.name);
    linkToAdd.set('source_uuid', linkJSON.source);
    linkToAdd.set('target_uuid', linkJSON.target);

    linkToAdd.addTo(graph);
    return linkToAdd; //For storing the runtime link object
}