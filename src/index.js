import * as joint from "@joint/core/dist/joint.js"
import graphData from './schema-compliant-cdd.json' assert {type: 'json'}
import {SaveButton} from "./uiButtons.js"
import { HTMLNode, HTMLNodeView } from "./htmlNode.js"

// --- CONFIG ---

const paperWidth = 2000;
const paperHeight = 2000;

//Used for text-based resizing
const minElementWidth = 120;
const maxElementWidth = 200;
const minElementHeight = 60;
//Do not limit height, so text can fully render

// --- MAIN GRAPH SETUP ---
var namespace = {
    shapes: joint.shapes,
    HTMLNode,
    HTMLNodeView
}

var graph = new joint.dia.Graph({}, { cellNamespace: namespace });

//Define canvas (paper)
var paper = new joint.dia.Paper({
    el: document.getElementById('myholder'), //div in static/index.html
    model: graph,
    width: paperWidth,
    height: paperHeight,
    background: {
        color: "#888888"
    },
    gridSize: 10,
    cellViewNamespace: namespace,
    interactive: function(cellView) {
        //Disable interaction on elements we've labeled non-interactive
        if(cellView.model.get('nonInteractive'))
        {
            return false;
        }

        //Otherwise, return the default value
        return {labelMove: false};
    }
});

//Read graph rectangle data from JSON
const graphElementsJSON = graphData.elements;

//Dictionary for storing runtime Rectangle objects
//Key: Rectangle UUID from JSON (string)
//Value: Rectangle object generated by JointJS
const graphElements = {};

//Send each rect's JSON data to add-to-graph function. Store runtime rects in the dict
graphElementsJSON.forEach((rectData) => graphElements[rectData.uuid] = addElementToGraph(rectData, graph, paper));


//Read graph link data from JSON
const graphLinksJSON = graphData.dependencies;

//Dictionary for storing runtime Link objects
//Key: Link UUID from JSON (string)
//Value: Link object generated by JointJS
const graphLinks = {};

//Send each link to add-to-graph function
graphLinksJSON.forEach((linkData) => graphLinks[linkData.uuid] = addLinkToGraph(linkData, graph, graphElements));

//Dictionary for storing runtime Function Button objects
//Key: Button UUID generated by uuidv4
//Value: Function Button with JointJS object etc.
const functionButtons = {};

//SAVE BUTTON
const saveButton = new SaveButton([graphData, graphElements, graphLinks]);
functionButtons[saveButton.uuid] = saveButton;
saveButton.JointRect.addTo(graph);



// --- EVENTS ---

/**
 * Click event (elements)
 */
paper.on('element:pointerclick', function (cell) {
    //Handles all function buttons
    if(cell.model.get('isFunctionButton'))
    {
        //Get the button by id, call its callback function with the supplied args array
        const buttonId = cell.model.get('uuid');
        const button = functionButtons[buttonId];
        button.callback(...button.args);    //Spread args to convert array to arguments
    }
});

// --- (OTHER) FUNCTIONS --

/**
 * Add an element with the given JSON values to the given graph.
 * Element JSON must be OpenDI-compliant.
 * 
 * @param {JSON} elementJSON Original raw JSON data for this element
 * @param {joint.dia.Graph} graph Graph object to add this element to
 * @param {Number} elementWidth (Optional) Width of this element
 * @param {Number} elementHeight (Optional) Height of this element
 * @returns {HTMLNode} Runtime representation of the element that was added
 */
function addElementToGraph(elementJSON, graph, paper, elementWidth = minElementWidth, elementHeight = minElementHeight, charWidth = 7)
{
    const diagramJSON = elementJSON.diagram;
    const elementType = elementJSON.type;
    const elementTitle = elementJSON.name;

    //Add a new element to the graph
    const elementToAdd = new HTMLNode();
    elementToAdd.addTo(graph);

    // -- SET VISUAL ATTRIBUTES --

    //Position
    elementToAdd.position(diagramJSON.position.x, diagramJSON.position.y);

    //Title
    elementToAdd.attr({
        label: {
            text: HTMLNode.formatString(elementTitle, maxElementWidth / charWidth)
        }
    });

    //Size
    HTMLNode.resizeElementBasedOnText(elementToAdd, paper, "label", undefined, {width: minElementWidth, height: minElementHeight});

    //Type (Set dropdown <select> menu to pre-select the right type)
    const typeAttrString = 'select' + elementType + "/props/selected";
    elementToAdd.attr(typeAttrString, true);

    /*
     * -- SET MODEL FIELDS --
     * 
     * See JointJS docs: https://resources.jointjs.com/docs/jointjs/v4.0/joint.html#mvc.Model.prototype.set
     * 
     * Element rectangle models will have the following fields:
     * uuid (string) - This element's UID. Used for storage/lookup in runtime rect dict
     * elementType (string) - Used to store the type of Decision Element contained in this area
     */
    elementToAdd.set('uuid', elementJSON.uuid);
    elementToAdd.set('elementType', elementType);

    return elementToAdd; //For storing the runtime rect object
}

/**
 * Add a link with the given JSON values to the given graph.
 * Link JSON must be OpenDI-compliant.
 * 
 * @param {JSON} linkJSON Original raw JSON data for this link
 * @param {joint.dia.Graph} graph Graph object to add this link to
 * @param {Array<joint.shapes.standard.Rectangle>} rectsInGraph Array of all rects in the graph
 * @returns {joint.shapes.standard.Link} Runtime representation of the link that was added
 */
function addLinkToGraph(linkJSON, graph, rectsInGraph)
{
    var linkToAdd = new joint.shapes.standard.Link();

    //Find source by the uuid given in JSON data
    linkToAdd.source(rectsInGraph["" + linkJSON.source]);
    //Find target by the uuid given in JSON data
    linkToAdd.target(rectsInGraph["" + linkJSON.target]);

    linkToAdd.addTo(graph);
    return linkToAdd; //For storing the runtime link object
}